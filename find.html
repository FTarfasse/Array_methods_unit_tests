<script src="C:/Users/fabri/Dropbox/Dev/Git/WatchAndCode/2_Testing/WatchAndCode/Array_methods_unit_tests/simpleTest.js"></script>
<script>

// function find(array, callback, initialValue, optionalThis) {};
function find(array, callback) {

	if(Array.isArray(array) === false) {

		throw new TypeError('.find is not a function')

	} else {
		var length = array.length;
		// var condition = false

		if(Boolean(callback() === false)) {
			for(var i = 0; i < length; i++) {
				callback();
			}
		//  } else {
		// 		callback();
			}
		}	
		// while the condition is false and i < array.length, iterate within each array element
		// if the value of the callback is true ==> quit the loops
	}
	

tests({
	// 'it should pass the ith element as the first argument to the callback': function() {
  //   find([1], function(number) {
  //     eq(number, 1); // number should be equal to 1
  //   });
  // },
  // 'It should pass in the ith position as the second argument to the callback': function() {
  //   find([1], function(number, index) {
  //     eq(index, 0);
  //   });
  // },
  // 'It should pass in the original array as the third argument to the callback': function() {
  //   var testArray = [1, 2, 3];
  //   find(testArray, function(number, index, originalArray) {
  //     // console.log(originalArray);
  //     eq(originalArray, testArray);
  //   });
  // },

	'It should take an array as an argument for the callback': function() {
		var testArray = [1, 2]
		find(testArray, function(element) {
		})
		eq(true, Array.isArray(testArray));
	},
	'It should throw an exception if the argument is not an array': function(){
		var isTypeError = false;
		var notAnArray = {};
    try {
      find(notAnArray, function () {});
    } catch(e) {
      isTypeError = (e instanceof TypeError);
    }
		eq(isTypeError, true);
	},
	'While condition is false, it should execute the callback function once per element': function() {
		var testArray = [1, 2, 3, 4];
		var numberOfCallBacks = 0;
		
		find(testArray,function(element) {
			debugger;
			// var i = 0;
			// var n = 3;
			while(element !== 10 && numberOfCallBacks < testArray.length) {
				numberOfCallBacks++;
			} return numberOfCallBacks;
		})
		eq(numberOfCallBacks, 4);
		// check the element value
		// check the number of callbacks
	},
	'It should return the matching value if the condition is true': function() {
		fail();
		// var filteredArray = filter([1, 2], function(number) {
    //   return number > 1;
    // });
    // eq(filteredArray.length, 1);
    // eq(filteredArray[0], 2);
	},
	'If condition is not met, it should return undefined': function() {
		fail();
	},
	'It should accept an optional this object': function() {
    // find([1], function() {
			fail();
			//   eq(this.description, 'I should be accessible inside of the callback');
    // }, {description: 'I should be accessible inside of the callback'});
	},
	'It should not mutate the array taken as an agument': function() {
		fail();
	},

	'It should not execute callback on empty values': function() {
		fail();
	},
	'It should not execute the callback on erased elements': function() {
		fail();
	},

	'Elements added after the call of find won\'t be exected by the callback': function() {
		fail();
	},
	'Elements deleted after the call of find won\'t be executed by the callback': function() {
		fail();
	}
});

	// 'It should stop searching when the first value of the array is returned': function() {},





</script>

<!-- <script>

function findor(array, callback) {
	// execute callback for each element of the array
}

</script> -->